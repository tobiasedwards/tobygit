{"type":"blob","contents":"var dir = require('./dir');\nvar fs = require('fs');\nvar path = require('path');\nvar sha1 = require('sha1');\n\nmodule.exports = {\n  /* Entries (files, dirs) which are not indexed */\n  IGNORED_ENTRIES: [dir.TOBYGIT_DIR, '.git', 'node_modules'],\n\n  /* Indexes a blob (file) and calls the provided callback with\n   * the arguments (err, blob).\n   */\n  indexBlob: function(blobPath, callback) {\n    var blob = {type: 'blob'};\n\n    fs.readFile(blobPath, function(err, data) {\n      if (err) {\n        callback(err, null);\n        return;\n      }\n\n      blob.contents = data.toString();\n      callback(null, blob);\n    });\n  },\n\n  /* Indexes a tree (directory) and calls the provided callback with the\n   * arguments (err, tree).\n   */\n  indexTree: function(treePath, callback) {\n    var tree = {type: 'tree'};\n\n    var entries = fs.readdirSync(treePath);\n    this.recursivelyIndexEntries(treePath, null, entries,\n      function(err, objects) {\n\n      if (err) {\n        callback(err, null);\n        return;\n      }\n\n      tree.objects = objects;\n      callback(null, tree);\n    });\n  },\n\n  /* Indexes an object to be added to a tree. The provided callback is called\n   * with the arguments (err, object).\n   */\n  indexObject: function(objectPath, callback) {\n    var stats = fs.lstatSync(objectPath);\n    if (stats.isDirectory()) {\n      this.indexTree(objectPath, callback);\n    } else if (stats.isFile()) {\n      this.indexBlob(objectPath, callback);\n    }\n  },\n\n  /* Processes an object and calls the provided callback with the arguments\n   * (err, processed), where processed is a javascript object that\n   * contains metadata about the object.\n   */\n  processObject: function(name, object, callback) {\n    var contents = JSON.stringify(object);\n    var hash = sha1(contents);\n\n    var objectFilePath = path.join(dir.tobygitDirPath(), 'objects', hash);\n    fs.open(objectFilePath, 'w', function(err, fd) {\n      if (err) {\n        callback(err, null);\n        return;\n      }\n\n      fs.write(fd, contents, function(err, written, string) {\n        if (err) {\n          callback(err, null);\n          return;\n        }\n\n        var processed = {\n          name: name,\n          hash: hash\n        };\n\n        callback(null, processed);\n      });\n    });\n\n\n  },\n\n  /* Recursively indexes each entry in an array of entries and then calls\n   * the callback provieded with the arguments (err, object).\n   */\n  recursivelyIndexEntries: function(basePath, objects, entries, callback) {\n    var objects = objects || [];\n\n    // When we have indexed all entries execute the callback\n    if (entries.length == 0) {\n      callback(null, objects);\n      return;\n    }\n\n    var entry = entries[0];\n\n    // If the entry is in the ignore array\n    if (this.IGNORED_ENTRIES.indexOf(entry) !== -1) {\n      this.recursivelyIndexEntries(basePath, objects,\n        entries.slice(1), callback);\n      return;\n    }\n\n    var objectPath = path.join(basePath, entry);\n    this.indexObject(objectPath, function(err, object) {\n      if (err) {\n        callback(err, null);\n        return;\n      }\n\n      this.processObject(entry, object, function(err, processed) {\n        objects.push(processed);\n        this.recursivelyIndexEntries(basePath, objects,\n          entries.slice(1), callback);\n      }.bind(this));\n    }.bind(this));\n  },\n};\n"}